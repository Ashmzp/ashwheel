/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AbortException = exports.AnnotationEditorParamsType = exports.AnnotationEditorType = exports.AnnotationFlag = exports.AnnotationMode = exports.AnnotationType = exports.CMapCompressionType = exports.ColorSpace = exports.DocumentInitParameters = exports.FeatureTest = exports.ImageKind = exports.InvalidPDFException = exports.MissingPDFException = exports.OPS = exports.PasswordResponses = exports.PermissionFlag = exports.PromiseCapability = exports.ReadableStream = exports.RenderingCancelledException = exports.RenderingIntent = exports.SVGGraphics = exports.ScrollMode = exports.SpreadMode = exports.UnexpectedResponseException = exports.UnknownErrorException = exports.UnsupportedManager = exports.Util = exports.VerbosityLevel = exports.XRefEntryException = exports.apiPageLayoutToViewerModes = exports.apiPageModeToViewerModes = exports.build = exports.createPromiseCapability = exports.createValidAbsoluteUrl = exports.getFilenameFromUrl = exports.getDocument = exports.getVerbosityLevel = exports.isPdfFile = exports.isSameOrigin = exports.isValidFetchUrl = exports.loadScript = exports.LoopbackPort = exports.PDFDataRangeTransport = exports.PDFDateString = exports.PDFWorker = exports.setVerbosityLevel = exports.shadow = exports.version = void 0;
exports.warn = warn;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var pdfjsLib;
if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) {
  pdfjsLib = window["pdfjs-dist/build/pdf"];
} else {
  pdfjsLib = require("../pdf.js");
}
var AbortException = pdfjsLib.AbortException;
exports.AbortException = AbortException;
var AnnotationEditorParamsType = pdfjsLib.AnnotationEditorParamsType;
exports.AnnotationEditorParamsType = AnnotationEditorParamsType;
var AnnotationEditorType = pdfjsLib.AnnotationEditorType;
exports.AnnotationEditorType = AnnotationEditorType;
var AnnotationFlag = pdfjsLib.AnnotationFlag;
exports.AnnotationFlag = AnnotationFlag;
var AnnotationMode = pdfjsLib.AnnotationMode;
exports.AnnotationMode = AnnotationMode;
var AnnotationType = pdfjsLib.AnnotationType;
exports.AnnotationType = AnnotationType;
var CMapCompressionType = pdfjsLib.CMapCompressionType;
exports.CMapCompressionType = CMapCompressionType;
var ColorSpace = pdfjsLib.ColorSpace;
exports.ColorSpace = ColorSpace;
var DocumentInitParameters = pdfjsLib.DocumentInitParameters;
exports.DocumentInitParameters = DocumentInitParameters;
var FeatureTest = pdfjsLib.FeatureTest;
exports.FeatureTest = FeatureTest;
var ImageKind = pdfjsLib.ImageKind;
exports.ImageKind = ImageKind;
var InvalidPDFException = pdfjsLib.InvalidPDFException;
exports.InvalidPDFException = InvalidPDFException;
var LoopbackPort = pdfjsLib.LoopbackPort;
exports.LoopbackPort = LoopbackPort;
var MissingPDFException = pdfjsLib.MissingPDFException;
exports.MissingPDFException = MissingPDFException;
var OPS = pdfjsLib.OPS;
exports.OPS = OPS;
var PDFDataRangeTransport = pdfjsLib.PDFDataRangeTransport;
exports.PDFDataRangeTransport = PDFDataRangeTransport;
var PDFDateString = pdfjsLib.PDFDateString;
exports.PDFDateString = PDFDateString;
var PDFWorker = pdfjsLib.PDFWorker;
exports.PDFWorker = PDFWorker;
var PasswordResponses = pdfjsLib.PasswordResponses;
exports.PasswordResponses = PasswordResponses;
var PermissionFlag = pdfjsLib.PermissionFlag;
exports.PermissionFlag = PermissionFlag;
var PromiseCapability = pdfjsLib.PromiseCapability;
exports.PromiseCapability = PromiseCapability;
var ReadableStream = pdfjsLib.ReadableStream;
exports.ReadableStream = ReadableStream;
var RenderingCancelledException = pdfjsLib.RenderingCancelledException;
exports.RenderingCancelledException = RenderingCancelledException;
var RenderingIntent = pdfjsLib.RenderingIntent;
exports.RenderingIntent = RenderingIntent;
var SVGGraphics = pdfjsLib.SVGGraphics;
exports.SVGGraphics = SVGGraphics;
var ScrollMode = pdfjsLib.ScrollMode;
exports.ScrollMode = ScrollMode;
var SpreadMode = pdfjsLib.SpreadMode;
exports.SpreadMode = SpreadMode;
var UnexpectedResponseException = pdfjsLib.UnexpectedResponseException;
exports.UnexpectedResponseException = UnexpectedResponseException;
var UnknownErrorException = pdfjsLib.UnknownErrorException;
exports.UnknownErrorException = UnknownErrorException;
var UnsupportedManager = pdfjsLib.UnsupportedManager;
exports.UnsupportedManager = UnsupportedManager;
var Util = pdfjsLib.Util;
exports.Util = Util;
var VerbosityLevel = pdfjsLib.VerbosityLevel;
exports.VerbosityLevel = VerbosityLevel;
var XRefEntryException = pdfjsLib.XRefEntryException;
exports.XRefEntryException = XRefEntryException;
var apiPageLayoutToViewerModes = pdfjsLib.apiPageLayoutToViewerModes;
exports.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes;
var apiPageModeToViewerModes = pdfjsLib.apiPageModeToViewerModes;
exports.apiPageModeToViewerModes = apiPageModeToViewerModes;
var build = pdfjsLib.build;
exports.build = build;
var createPromiseCapability = pdfjsLib.createPromiseCapability;
exports.createPromiseCapability = createPromiseCapability;
var createValidAbsoluteUrl = pdfjsLib.createValidAbsoluteUrl;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
var getDocument = pdfjsLib.getDocument;
exports.getDocument = getDocument;
var getFilenameFromUrl = pdfjsLib.getFilenameFromUrl;
exports.getFilenameFromUrl = getFilenameFromUrl;
var getVerbosityLevel = pdfjsLib.getVerbosityLevel;
exports.getVerbosityLevel = getVerbosityLevel;
var isPdfFile = pdfjsLib.isPdfFile;
exports.isPdfFile = isPdfFile;
var isSameOrigin = pdfjsLib.isSameOrigin;
exports.isSameOrigin = isSameOrigin;
var isValidFetchUrl = pdfjsLib.isValidFetchUrl;
exports.isValidFetchUrl = isValidFetchUrl;
var loadScript = pdfjsLib.loadScript;
exports.loadScript = loadScript;
var setVerbosityLevel = pdfjsLib.setVerbosityLevel;
exports.setVerbosityLevel = setVerbosityLevel;
var shadow = pdfjsLib.shadow;
exports.shadow = shadow;
var version = pdfjsLib.version;
exports.version = version;
function warn(msg) {
  pdfjsLib.warn(msg);
}
var WorkerMessageHandler = /*#__PURE__*/function () {
  function WorkerMessageHandler() {
    _classCallCheck(this, WorkerMessageHandler);
  }
  _createClass(WorkerMessageHandler, null, [{
    key: "setup",
    value: function setup(handler, port) {
      var testMessageProcessed = false;
      handler.on("test", function (data) {
        if (testMessageProcessed) {
          return;
        }
        testMessageProcessed = true;
        if (!(data instanceof Uint8Array)) {
          handler.send("test", null);
          return;
        }
        var supportTransfers = data[0] === 255;
        handler.postMessageTransfers = supportTransfers;
        var response = new Uint8Array(1);
        response[0] = supportTransfers ? 255 : 0;
        handler.send("test", response, [response.buffer]);
      });
      handler.on("configure", function (data) {
        if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("GENERIC")) {
          (0, pdfjsLib.setVerbosityLevel)(data.verbosity);
        }
      });
      handler.on("GetDocRequest", function (data, sink) {
        var source = data.source;
        if (source.data) {
          source.data = (0, pdfjsLib.arrayBufferToBytes)(source.data);
        } else if (source.range) {
          source.range = new pdfjsLib.PDFDataRangeTransport(source.range.length, source.range.initialData, source.range.progressiveDone);
        } else if (source.stream) {
          var reader = source.stream.getReader();
          var stream = new pdfjsLib.ReadableStream({
            start: function start(controller) {
              reader.read().then(function process(result) {
                if (result.done) {
                  controller.close();
                  return;
                }
                controller.enqueue(result.value);
                reader.read().then(process);
              });
            }
          });
          source.stream = stream;
        }
        var doc = (0, pdfjsLib.getDocument)(source);
        doc.promise.then(function (pdfDocument) {
          var _pdfDocument$seriali = pdfDocument.serialize(),
            doc = _pdfDocument$seriali.doc,
            transport = _pdfDocument$seriali.transport;
          sink.resolve({
            doc: doc,
            transport: transport
          });
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetData", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getData(data.docId, data.chunk).then(function (chunk) {
          sink.resolve(chunk);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetPageRequest", function (data, sink) {
        var page = pdfjsLib.PDFDocumentFactory.getPage(data.docId, data.pageIndex);
        page.then(function (pdfPage) {
          sink.resolve(pdfPage.serialize());
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetDestinations", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getDestinations(data.docId).then(function (destinations) {
          sink.resolve(destinations);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetPageLabels", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getPageLabels(data.docId).then(function (labels) {
          sink.resolve(labels);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetPageLayout", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getPageLayout(data.docId).then(function (layout) {
          sink.resolve(layout);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetPageMode", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getPageMode(data.docId).then(function (mode) {
          sink.resolve(mode);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetViewerPreferences", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getViewerPreferences(data.docId).then(function (prefs) {
          sink.resolve(prefs);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetOpenAction", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getOpenAction(data.docId).then(function (action) {
          sink.resolve(action);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetAttachments", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getAttachments(data.docId).then(function (attachments) {
          sink.resolve(attachments);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetJavaScript", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getJavaScript(data.docId).then(function (javascript) {
          sink.resolve(javascript);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetDocJSActions", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getDocJSActions(data.docId).then(function (actions) {
          sink.resolve(actions);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetPageJSActions", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getPageJSActions(data.docId, data.pageIndex).then(function (actions) {
          sink.resolve(actions);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetMetadata", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getMetadata(data.docId).then(function (metadata) {
          sink.resolve(metadata);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetMarkedContent", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getMarkedContent(data.docId, data.pageIndex).then(function (markedContent) {
          sink.resolve(markedContent);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetStructTree", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getStructTree(data.docId).then(function (structTree) {
          sink.resolve(structTree);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetPermissions", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getPermissions(data.docId).then(function (permissions) {
          sink.resolve(permissions);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetFingerprint", function (data, sink) {
        var fingerprint = pdfjsLib.PDFDocumentFactory.getFingerprint(data.docId);
        sink.resolve(fingerprint);
      });
      handler.on("GetOperatorList", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getOperatorList(data.docId, data.pageIndex, data.intent, data.cacheKey).then(function (operatorList) {
          sink.resolve(operatorList);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetAnnotations", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getAnnotations(data.docId, data.pageIndex, data.intent).then(function (annotations) {
          sink.resolve(annotations);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetFieldObjects", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getFieldObjects(data.docId).then(function (fieldObjects) {
          sink.resolve(fieldObjects);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("HasJSActions", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.hasJSActions(data.docId).then(function (hasJSActions) {
          sink.resolve(hasJSActions);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetCalculationOrderIds", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getCalculationOrderIds(data.docId).then(function (ids) {
          sink.resolve(ids);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("SaveDocument", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.saveDocument(data.docId, data.annotationStorage).then(function (res) {
          sink.resolve(res);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetOptionalContentConfig", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getOptionalContentConfig(data.docId).then(function (config) {
          sink.resolve(config);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("SetOptionalContentConfig", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.setOptionalContentConfig(data.docId, data.config).then(function () {
          sink.resolve();
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("GetXfa", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.getXfa(data.docId).then(function (xfa) {
          sink.resolve(xfa);
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("FontFallback", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.fontFallback(data.docId, data.id, data.handler).then(function () {
          sink.resolve();
        }, function (reason) {
          sink.reject(reason);
        });
      });
      handler.on("Cleanup", function (data, sink) {
        pdfjsLib.PDFDocumentFactory.cleanup(data.docId);
        sink.resolve();
      });
      handler.on("Terminate", function (data) {
        if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("GENERIC")) {
          (0, pdfjsLib.setVerbosityLevel)(VerbosityLevel.ERRORS);
        }
        if (port) {
          port.close();
        }
      });
      handler.on("commonobj", function (data) {
        (0, pdfjsLib.getCommonObjs)(data);
      });
      handler.on("font", function (data) {
        (0, pdfjsLib.getFont)(data);
      });
      handler.on("AnnotationRequest", function (data, sink) {
        pdfjsLib.AnnotationFactory.create(data.docId, data.annotationData).then(function (annotation) {
          sink.resolve(annotation.serialize());
        }, function (reason) {
          sink.reject(reason);
        });
      });
    }
  }]);
  return WorkerMessageHandler;
}();
var ComObj = /*#__PURE__*/function () {
  function ComObj(data) {
    _classCallCheck(this, ComObj);
    this.data = data;
  }
  _createClass(ComObj, [{
    key: "get",
    value: function get(name) {
      return this.data[name];
    }
  }]);
  return ComObj;
}();
var AppOptions = /*#__PURE__*/function () {
  function AppOptions() {
    _classCallCheck(this, AppOptions);
    throw new Error("Cannot initialize AppOptions.");
  }
  _createClass(AppOptions, null, [{
    key: "get",
    value: function get(name) {
      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("CHROME")) {
        return defaultPreferences.get(name);
      }
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
        return this._options[name];
      }
      return undefined;
    }
  }, {
    key: "getAll",
    value: function getAll(kind) {
      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("CHROME")) {
        return defaultPreferences.getAll(kind);
      }
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
        var options = Object.create(null);
        for (var name in this._options) {
          options[name] = this._options[name];
        }
        return options;
      }
      return undefined;
    }
  }, {
    key: "set",
    value: function set(name, value) {
      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("CHROME")) {
        throw new Error("Not implemented: AppOptions.set");
      }
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
        this._options[name] = value;
      }
    }
  }, {
    key: "setAll",
    value: function setAll(options) {
      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("CHROME")) {
        throw new Error("Not implemented: AppOptions.setAll");
      }
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
        for (var name in options) {
          this._options[name] = options[name];
        }
      }
    }
  }, {
    key: "remove",
    value: function remove(name) {
      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("CHROME")) {
        throw new Error("Not implemented: AppOptions.remove");
      }
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
        delete this._options[name];
      }
    }
  }]);
  return AppOptions;
}();
AppOptions._options = Object.create(null);
var PDFViewerApplication = /*#__PURE__*/function () {
  function PDFViewerApplication() {
    _classCallCheck(this, PDFViewerApplication);
    throw new Error("Cannot initialize PDFViewerApplication.");
  }
  _createClass(PDFViewerApplication, null, [{
    key: "initialize",
    value: function initialize(appConfig) {
      throw new Error("Not implemented: PDFViewerApplication.initialize");
    }
  }, {
    key: "run",
    value: function run(config) {
      throw new Error("Not implemented: PDFViewerApplication.run");
    }
  }, {
    key: "isViewerEmbedded",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "isViewerEmbedded", true);
    }
  }, {
    key: "pdfDocument",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfDocument", null);
    }
  }, {
    key: "pdfLoadingTask",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfLoadingTask", null);
    }
  }, {
    key: "pdfViewer",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfViewer", null);
    }
  }, {
    key: "pdfHistory",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfHistory", null);
    }
  }, {
    key: "pdfLinkService",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfLinkService", null);
    }
  }, {
    key: "pdfOutlineViewer",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfOutlineViewer", null);
    }
  }, {
    key: "pdfAttachmentViewer",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfAttachmentViewer", null);
    }
  }, {
    key: "pdfLayerViewer",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfLayerViewer", null);
    }
  }, {
    key: "pdfThumbnailViewer",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfThumbnailViewer", null);
    }
  }, {
    key: "findBar",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "findBar", null);
    }
  }, {
    key: "findController",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "findController", null);
    }
  }, {
    key: "scriptingManager",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "scriptingManager", null);
    }
  }, {
    key: "page",
    get: function get() {
      var _this$pdfViewer;
      return ((_this$pdfViewer = this.pdfViewer) === null || _this$pdfViewer === void 0 ? void 0 : _this$pdfViewer.currentPageNumber) || 1;
    },
    set: function set(val) {
      if (this.pdfViewer) {
        this.pdfViewer.currentPageNumber = val;
      }
    }
  }, {
    key: "zoom",
    get: function get() {
      var _this$pdfViewer2;
      return ((_this$pdfViewer2 = this.pdfViewer) === null || _this$pdfViewer2 === void 0 ? void 0 : _this$pdfViewer2.currentScaleValue) || "auto";
    },
    set: function set(val) {
      if (this.pdfViewer) {
        this.pdfViewer.currentScaleValue = val;
      }
    }
  }, {
    key: "rotation",
    get: function get() {
      var _this$pdfViewer3;
      return ((_this$pdfViewer3 = this.pdfViewer) === null || _this$pdfViewer3 === void 0 ? void 0 : _this$pdfViewer3.pagesRotation) || 0;
    },
    set: function set(val) {
      if (this.pdfViewer) {
        this.pdfViewer.pagesRotation = val;
      }
    }
  }]);
  return PDFViewerApplication;
}();
var PDFPrintServiceFactory = {
  instance: {
    supportsPrinting: false,
    createPrintService: function createPrintService() {
      throw new Error("Not implemented: createPrintService");
    }
  }
};
var DefaultExternalServices = /*#__PURE__*/function () {
  function DefaultExternalServices() {
    _classCallCheck(this, DefaultExternalServices);
  }
  _createClass(DefaultExternalServices, null, [{
    key: "updateFindControlState",
    value: function updateFindControlState(data) {}
  }, {
    key: "updateFindMatchesCount",
    value: function updateFindMatchesCount(data) {}
  }, {
    key: "initPassiveLoading",
    value: function initPassiveLoading(callbacks) {}
  }, {
    key: "reportTelemetry",
    value: function reportTelemetry(data) {}
  }, {
    key: "createDownloadManager",
    value: function createDownloadManager(options) {
      throw new Error("Not implemented: createDownloadManager");
    }
  }, {
    key: "createPreferences",
    value: function createPreferences() {
      throw new Error("Not implemented: createPreferences");
    }
  }, {
    key: "createL10n",
    value: function createL10n(options) {
      throw new Error("Not implemented: createL10n");
    }
  }, {
    key: "createScripting",
    value: function createScripting(options) {
      throw new Error("Not implemented: createScripting");
    }
  }, {
    key: "updateEditorStates",
    value: function updateEditorStates(data) {
      throw new Error("Not implemented: updateEditorStates");
    }
  }, {
    key: "dispatchGlobalEvent",
    value: function dispatchGlobalEvent(data) {
      throw new Error("Not implemented: dispatchGlobalEvent");
    }
  }, {
    key: "reportPageStats",
    value: function reportPageStats(data) {
      console.log("Page stats: ".concat(JSON.stringify(data)));
    }
  }, {
    key: "appConfig",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "appConfig", null);
    }
  }, {
    key: "pdfViewer",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfViewer", null);
    }
  }, {
    key: "pdfLinkService",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "pdfLinkService", null);
    }
  }, {
    key: "downloadManager",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "downloadManager", null);
    }
  }, {
    key: "preferences",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "preferences", null);
    }
  }, {
    key: "l10n",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "l10n", null);
    }
  }, {
    key: "scripting",
    get: function get() {
      return (0, pdfjsLib.shadow)(this, "scripting", null);
    }
  }]);
  return DefaultExternalServices;
}();
var MozPrintCallback = /*#__PURE__*/function () {
  function MozPrintCallback(obj, callback) {
    _classCallCheck(this, MozPrintCallback);
    this.obj = obj;
    this.callback = callback;
  }
  _createClass(MozPrintCallback, [{
    key: "QueryInterface",
    value: function QueryInterface(iid) {
      if (iid.equals(Ci.nsIWebProgressListener) || iid.equals(Ci.nsISupportsWeakReference) || iid.equals(Ci.nsISupports)) {
        return this;
      }
      throw Cr.NS_ERROR_NO_INTERFACE;
    }
  }, {
    key: "onStateChange",
    value: function onStateChange(webProgress, request, stateFlags, status) {
      if (stateFlags & Ci.nsIWebProgressListener.STATE_STOP) {
        this.callback(this.obj, null);
      }
    }
  }, {
    key: "onLocationChange",
    value: function onLocationChange(webProgress, request, location, flags) {}
  }, {
    key: "onProgressChange",
    value: function onProgressChange(webProgress, request, curSelf, maxSelf, curTotal, maxTotal) {}
  }, {
    key: "onStatusChange",
    value: function onStatusChange(webProgress, request, status, message) {}
  }, {
    key: "onSecurityChange",
    value: function onSecurityChange(webProgress, request, state) {}
  }, {
    key: "onLinkIconAvailable",
    value: function onLinkIconAvailable(iconURL) {}
  }]);
  return MozPrintCallback;
}();
var PDFPrintService = /*#__PURE__*/function () {
  function PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise) {
    var l10n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : pdfjsLib.NullL10n;
    _classCallCheck(this, PDFPrintService);
    this.pdfDocument = pdfDocument;
    this.pagesOverview = pagesOverview;
    this.printContainer = printContainer;
    this._printResolution = printResolution || 150;
    this._optionalContentConfigPromise = optionalContentConfigPromise || pdfDocument.getOptionalContentConfig();
    this.l10n = l10n;
    this.currentPage = -1;
    this.scratchCanvas = document.createElement("canvas");
  }
  _createClass(PDFPrintService, [{
    key: "layout",
    value: function layout() {
      this.throwIfInactive();
      var body = document.querySelector("body");
      body.setAttribute("data-pdfjsprinting", true);
      var hasEqualPageSizes = this.pagesOverview.every(function (size) {
        return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height;
      }, this);
      if (!hasEqualPageSizes) {
        console.warn("Not all pages have the same size. The printed result may be incorrect!");
      }
      this.pageStyleSheet = document.createElement("style");
      var pageSize = this.pagesOverview[0];
      this.pageStyleSheet.textContent = "@page { size: " + pageSize.width + "pt " + pageSize.height + "pt;}";
      body.append(this.pageStyleSheet);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.pdfDocument) {
        return;
      }
      this.throwIfInactive();
      var body = document.querySelector("body");
      body.removeAttribute("data-pdfjsprinting");
      if (this.pageStyleSheet) {
        this.pageStyleSheet.remove();
        this.pageStyleSheet = null;
      }
      this.scratchCanvas.width = this.scratchCanvas.height = 0;
      this.scratchCanvas = null;
      this.pdfDocument = null;
      this.pagesOverview = null;
      this.printContainer = null;
      this._optionalContentConfigPromise = null;
    }
  }, {
    key: "renderPages",
    value: function renderPages() {
      var _this = this;
      this.throwIfInactive();
      var pageCount = this.pagesOverview.length;
      var renderNextPage = function renderNextPage(resolve, reject) {
        _this.currentPage++;
        if (_this.currentPage >= pageCount) {
          resolve();
          return;
        }
        var page = _this.pdfDocument.getPage(_this.currentPage + 1);
        var pageOverview = _this.pagesOverview[_this.currentPage];
        var container = document.createElement("div");
        _this.printContainer.append(container);
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        canvas.width = Math.floor(pageOverview.width * _this._printResolution / 72);
        canvas.height = Math.floor(pageOverview.height * _this._printResolution / 72);
        var renderContext = {
          canvasContext: ctx,
          transform: [1, 0, 0, 1, 0, 0],
          viewport: page.getViewport({
            scale: _this._printResolution / 72,
            rotation: pageOverview.rotation
          }),
          intent: "print",
          optionalContentConfigPromise: _this._optionalContentConfigPromise
        };
        page.render(renderContext).promise.then(function () {
          var img = document.createElement("img");
          img.src = canvas.toDataURL();
          container.append(img);
          renderNextPage(resolve, reject);
        }, reject);
      };
      return new Promise(renderNextPage);
    }
  }, {
    key: "throwIfInactive",
    value: function throwIfInactive() {
      if (!this.pdfDocument) {
        throw new Error("This print service is not active.");
      }
    }
  }]);
  return PDFPrintService;
}();
var PDFSinglePageViewer = /*#__PURE__*/function (_pdfjsLib$PDFViewer) {
  _inherits(PDFSinglePageViewer, _pdfjsLib$PDFViewer);
  var _super = _createSuper(PDFSinglePageViewer);
  function PDFSinglePageViewer(options) {
    var _this2;
    _classCallCheck(this, PDFSinglePageViewer);
    _this2 = _super.call(this, options);
    _this2.eventBus.on("pagesinit", function (evt) {
      _this2._ensurePageViewVisible();
    });
    return _this2;
  }
  _createClass(PDFSinglePageViewer, [{
    key: "_resetView",
    value: function _resetView() {
      _get(_getPrototypeOf(PDFSinglePageViewer.prototype), "_resetView", this).call(this);
      this._previousPageNumber = 1;
      this._nextPageNumber = 1;
    }
  }, {
    key: "_ensurePageViewVisible",
    value: function _ensurePageViewVisible() {
      var pageView = this._pages[this._currentPageNumber - 1];
      var previousPageView = this._pages[this._previousPageNumber - 1];
      var nextPageView = this._pages[this._nextPageNumber - 1];
      if (pageView === previousPageView) {
        previousPageView.div.style.visibility = "";
        previousPageView.div.style.zIndex = 0;
        previousPageView.div.style.transform = "scale(".concat(this._currentScale, ")");
      } else if (pageView === nextPageView) {
        nextPageView.div.style.visibility = "";
        nextPageView.div.style.zIndex = 0;
        nextPageView.div.style.transform = "scale(".concat(this._currentScale, ")");
      } else {
        pageView.div.style.visibility = "";
        pageView.div.style.zIndex = 0;
        pageView.div.style.transform = "scale(".concat(this._currentScale, ")");
        if (previousPageView) {
          previousPageView.div.style.visibility = "hidden";
          previousPageView.div.style.zIndex = -1;
          previousPageView.div.style.transform = "scale(1)";
        }
        if (nextPageView) {
          nextPageView.div.style.visibility = "hidden";
          nextPageView.div.style.zIndex = -1;
          nextPageView.div.style.transform = "scale(1)";
        }
      }
    }
  }, {
    key: "_scrollUpdate",
    value: function _scrollUpdate() {
      if (this.pagesCount === 0) {
        return;
      }
      this.update();
    }
  }, {
    key: "_scrollIntoView",
    value: function _scrollIntoView(_ref) {
      var pageDiv = _ref.pageDiv;
      pageDiv.scrollIntoView();
    }
  }, {
    key: "_getVisiblePages",
    value: function _getVisiblePages() {
      if (this.pagesCount === 0) {
        return {
          first: null,
          last: null,
          views: []
        };
      }
      var pageView = this._pages[this._currentPageNumber - 1];
      var visible = [{
        id: pageView.id,
        x: pageView.x,
        y: pageView.y,
        view: pageView,
        percent: 100
      }];
      return {
        first: pageView,
        last: pageView,
        views: visible
      };
    }
  }, {
    key: "update",
    value: function update() {
      var visible = this._getVisiblePages();
      var visiblePages = visible.views,
        numVisiblePages = visiblePages.length;
      if (numVisiblePages === 0) {
        return;
      }
      this._resizeBuffer(numVisiblePages, visiblePages);
      this.renderingQueue.renderHighestPriority(visible);
      var currentId = this._currentPageNumber;
      var stillFullyVisible = false;
      for (var i = 0; i < numVisiblePages; ++i) {
        var page = visiblePages[i];
        if (page.percent < 100) {
          break;
        }
        if (page.id === currentId) {
          stillFullyVisible = true;
          break;
        }
      }
      if (!stillFullyVisible) {
        currentId = visiblePages[0].id;
      }
      this._updateLocation(visible.first);
      this.eventBus.dispatch("updateviewarea", {
        source: this,
        location: this._location
      });
    }
  }, {
    key: "pagesRotation",
    set: function set(rotation) {
      if (!(typeof rotation === "number" && rotation % 90 === 0)) {
        throw new Error("Invalid pages rotation angle.");
      }
      this._pagesRotation = rotation;
      if (!this.pdfDocument) {
        return;
      }
      for (var i = 0, ii = this._pages.length; i < ii; i++) {
        var pageView = this._pages[i];
        pageView.update(pageView.scale, rotation);
      }
      this._setScale(this._currentScaleValue, true);
      if (this.defaultRenderingQueue) {
        this.update();
      }
    }
  }]);
  return PDFSinglePageViewer;
}(pdfjsLib.PDFViewer);

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SimpleLinkService = exports.PDFLinkService = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var PDFLinkService = /*#__PURE__*/function () {
  function PDFLinkService() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      eventBus = _ref.eventBus,
      _ref$externalLinkTarg = _ref.externalLinkTarget,
      externalLinkTarget = _ref$externalLinkTarg === void 0 ? null : _ref$externalLinkTarg,
      _ref$externalLinkRel = _ref.externalLinkRel,
      externalLinkRel = _ref$externalLinkRel === void 0 ? null : _ref$externalLinkRel,
      _ref$externalLinkEnab = _ref.externalLinkEnabled,
      externalLinkEnabled = _ref$externalLinkEnab === void 0 ? true : _ref$externalLinkEnab,
      _ref$ignoreDestinatio = _ref.ignoreDestinationZoom,
      ignoreDestinationZoom = _ref$ignoreDestinatio === void 0 ? false : _ref$ignoreDestinatio;
    _classCallCheck(this, PDFLinkService);
    this.eventBus = eventBus;
    this.externalLinkTarget = externalLinkTarget;
    this.externalLinkRel = externalLinkRel;
    this.externalLinkEnabled = externalLinkEnabled;
    this._ignoreDestinationZoom = ignoreDestinationZoom;
    this.baseUrl = null;
    this.pdfDocument = null;
    this.pdfViewer = null;
    this.pdfHistory = null;
    this._pagesRefCache = null;
  }
  _createClass(PDFLinkService, [{
    key: "setDocument",
    value: function setDocument(pdfDocument, baseUrl) {
      this.baseUrl = baseUrl;
      this.pdfDocument = pdfDocument;
      this._pagesRefCache = Object.create(null);
    }
  }, {
    key: "setViewer",
    value: function setViewer(pdfViewer) {
      this.pdfViewer = pdfViewer;
    }
  }, {
    key: "setHistory",
    value: function setHistory(pdfHistory) {
      this.pdfHistory = pdfHistory;
    }
  }, {
    key: "pagesCount",
    get: function get() {
      return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
  }, {
    key: "page",
    get: function get() {
      return this.pdfViewer.currentPageNumber;
    },
    set: function set(value) {
      this.pdfViewer.currentPageNumber = value;
    }
  }, {
    key: "rotation",
    get: function get() {
      return this.pdfViewer.pagesRotation;
    },
    set: function set(value) {
      this.pdfViewer.pagesRotation = value;
    }
  }, {
    key: "goToDestination",
    value: function goToDestination(dest) {
      var _this = this;
      var goToDestination = function goToDestination(destination) {
        var explicitDest = destination instanceof Array ? destination : destination.dest;
        if (!(explicitDest instanceof Array)) {
          console.error("goToDestination: \"".concat(explicitDest, "\" is not a valid destination array."));
          return;
        }
        var destRef = explicitDest[0];
        var pageNumber;
        if (_typeof(destRef) === "object" && destRef !== null) {
          pageNumber = _this._cachedPageNumber(destRef);
          if (pageNumber === null) {
            _this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {
              _this.cachePageRef(pageIndex + 1, destRef);
              goToDestination(destination);
            })["catch"](function () {
              console.error("goToDestination: \"".concat(destRef, "\" is not a valid page reference."));
            });
            return;
          }
        } else if (Number.isInteger(destRef)) {
          pageNumber = destRef + 1;
        } else {
          console.error("goToDestination: \"".concat(destRef, "\" is not a valid destination reference."));
          return;
        }
        if (!pageNumber || pageNumber < 1 || pageNumber > _this.pagesCount) {
          console.error("goToDestination: \"".concat(pageNumber, "\" is not a valid page number."));
          return;
        }
        if (_this.pdfHistory) {
          _this.pdfHistory.pushCurrentPosition();
          _this.pdfHistory.push({
            dest: explicitDest,
            hash: _this.currentHash,
            page: pageNumber,
            rotation: _this.rotation
          });
        }
        _this.pdfViewer.scrollPageIntoView({
          pageNumber: pageNumber,
          destArray: explicitDest,
          ignoreDestinationZoom: _this._ignoreDestinationZoom
        });
      };
      new Promise(function (resolve) {
        if (typeof dest === "string") {
          _this.pdfDocument.getDestination(dest).then(function (destination) {
            resolve(destination);
          });
          return;
        }
        resolve(dest);
      }).then(function (destination) {
        if (!(destination instanceof Array)) {
          return;
        }
        goToDestination(destination);
      });
    }
  }, {
    key: "goToPage",
    value: function goToPage(val) {
      if (!this.pdfDocument) {
        return;
      }
      var pageNumber;
      if (Number.isInteger(val)) {
        pageNumber = val;
      } else {
        pageNumber = this.pdfDocument.getPageIndex(val) + 1;
      }
      if (pageNumber > 0 && pageNumber <= this.pagesCount) {
        if (this.pdfHistory) {
          this.pdfHistory.pushCurrentPosition();
        }
        this.pdfViewer.currentPageNumber = pageNumber;
      } else {
        console.error("PDFLinkService.goToPage: \"".concat(val, "\" is not a valid page."));
      }
    }
  }, {
    key: "getDestinationHash",
    value: function getDestinationHash(dest) {
      if (typeof dest === "string") {
        if (dest.length > 0) {
          return this.getAnchorUrl("#" + escape(dest));
        }
      } else if (dest instanceof Array) {
        var str = JSON.stringify(dest);
        if (str.length > 0) {
          return this.getAnchorUrl("#" + escape(str));
        }
      }
      return this.getAnchorUrl("");
    }
  }, {
    key: "getAnchorUrl",
    value: function getAnchorUrl(anchor) {
      return this.baseUrl ? this.baseUrl + anchor : anchor;
    }
  }, {
    key: "setHash",
    value: function setHash(hash) {
      if (!this.pdfDocument) {
        return;
      }
      var pageNumber, dest;
      if (hash.includes("=")) {
        var params = (0, pdfjs_lib.parseQueryString)(hash);
        if (params.has("page")) {
          pageNumber = parseInt(params.get("page"), 10) | 0;
        }
        if (params.has("zoom")) {
          var zoomArgs = params.get("zoom").split(",");
          var zoomArg = zoomArgs[0];
          var zoomArgNumber = parseFloat(zoomArg);
          if (!zoomArg.includes("=")) {
            if (zoomArgNumber) {
              zoomArg = zoomArgNumber * 100;
            }
            dest = [null, {
              name: "FitH"
            }, null];
            var zoomSecondArg = zoomArgs[1];
            if (zoomSecondArg) {
              var zoomSecondArgNumber = parseFloat(zoomSecondArg);
              if (zoomSecondArgNumber) {
                dest[2] = zoomSecondArgNumber | 0;
              }
            }
          } else {
            if (zoomArg === "Fit" || zoomArg === "FitB") {
              dest = [null, {
                name: zoomArg
              }];
            } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
              dest = [null, {
                name: zoomArg
              }, zoomArgs.length > 1 ? parseFloat(zoomArgs[1]) | 0 : null];
            } else if (zoomArg === "XYZ") {
              var H = parseFloat(zoomArgs[1]) | 0;
              var V = parseFloat(zoomArgs[2]) | 0;
              var Z = parseFloat(zoomArgs[3]) | 0;
              dest = [null, {
                name: zoomArg
              }, H, V, Z];
            }
          }
        }
        if (dest) {
          this.pdfViewer.scrollPageIntoView({
            pageNumber: pageNumber || this.page,
            destArray: dest,
            allowNegativeOffset: true
          });
        } else if (pageNumber) {
          this.page = pageNumber;
        }
        if (params.has("pagemode")) {
          this.eventBus.dispatch("pagemode", {
            source: this,
            mode: params.get("pagemode")
          });
        }
        if (params.has("nameddest")) {
          this.goToDestination(params.get("nameddest"));
        }
      } else {
        dest = unescape(hash);
        try {
          dest = JSON.parse(dest);
          if (!(dest instanceof Array)) {
            dest = dest.toString();
          }
        } catch (ex) {}
        if (typeof dest === "string" || isValidExplicitDestination(dest)) {
          this.goToDestination(dest);
          return;
        }
        console.error("PDFLinkService.setHash: \"".concat(unescape(hash), "\" is not a valid destination."));
      }
    }
  }, {
    key: "executeNamedAction",
    value: function executeNamedAction(action) {
      switch (action) {
        case "GoBack":
          if (this.pdfHistory) {
            this.pdfHistory.back();
          }
          break;
        case "GoForward":
          if (this.pdfHistory) {
            this.pdfHistory.forward();
          }
          break;
        case "NextPage":
          this.pdfViewer.nextPage();
          break;
        case "PrevPage":
          this.pdfViewer.previousPage();
          break;
        case "LastPage":
          this.page = this.pagesCount;
          break;
        case "FirstPage":
          this.page = 1;
          break;
        default:
          break;
      }
      this.eventBus.dispatch("namedaction", {
        source: this,
        action: action
      });
    }
  }, {
    key: "cachePageRef",
    value: function cachePageRef(pageNum, pageRef) {
      if (!pageRef) {
        return;
      }
      var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);
      this._pagesRefCache[refStr] = pageNum;
    }
  }, {
    key: "_cachedPageNumber",
    value: function _cachedPageNumber(pageRef) {
      if (!pageRef) {
        return null;
      }
      var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);
      return this._pagesRefCache?.[refStr] || null;
    }
  }, {
    key: "isPageVisible",
    value: function isPageVisible(pageNumber) {
      return this.pdfViewer.isPageVisible(pageNumber);
    }
  }, {
    key: "isPageCached",
    value: function isPageCached(pageNumber) {
      return this.pdfViewer.isPageCached(pageNumber);
    }
  }]);
  return PDFLinkService;
}();
exports.PDFLinkService = PDFLinkService;
function isValidExplicitDestination(dest) {
  if (!(dest instanceof Array)) {
    return false;
  }
  var destLength = dest.length;
  if (destLength < 2) {
    return false;
  }
  var page = dest[0];
  if (!(_typeof(page) === "object" && typeof page.num === "number" && Number.isInteger(page.num) && typeof page.gen === "number" && Number.isInteger(page.gen)) && !(typeof page === "number" && Number.isInteger(page))) {
    return false;
  }
  var zoom = dest[1];
  if (!(_typeof(zoom) === "object" && typeof zoom.name === "string")) {
    return false;
  }
  var allowNull = true;
  switch (zoom.name) {
    case "XYZ":
      if (destLength !== 5) {
        return false;
      }
      break;
    case "Fit":
    case "FitB":
      return destLength === 2;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (destLength !== 3) {
        return false;
      }
      break;
    case "FitR":
      if (destLength !== 6) {
        return false;
      }
      allowNull = false;
      break;
    default:
      return false;
  }
  for (var i = 2; i < destLength; i++) {
    var param = dest[i];
    if (!(typeof param === "number" || allowNull && param === null)) {
      return false;
    }
  }
  return true;
}
var SimpleLinkService = /*#__PURE__*/function () {
  function SimpleLinkService() {
    _classCallCheck(this, SimpleLinkService);
    this.externalLinkTarget = null;
    this.externalLinkRel = null;
    this.externalLinkEnabled = true;
    this._ignoreDestinationZoom = false;
  }
  _createClass(SimpleLinkService, [{
    key: "pagesCount",
    get: function get() {
      return 0;
    }
  }, {
    key: "page",
    get: function get() {
      return 0;
    },
    set: function set(value) {}
  }, {
    key: "rotation",
    get: function get() {
      return 0;
    },
    set: function set(value) {}
  }, {
    key: "goToDestination",
    value: function goToDestination(dest) {
      return Promise.resolve();
    }
  }, {
    key: "goToPage",
    value: function goToPage(val) {}
  }, {
    key: "getDestinationHash",
    value: function getDestinationHash(dest) {
      return "#";
    }
  }, {
    key: "getAnchorUrl",
    value: function getAnchorUrl(hash) {
      return "#";
    }
  }, {
    key: "setHash",
    value: function setHash(hash) {}
  }, {
    key: "executeNamedAction",
    value: function executeNamedAction(action) {}
  }, {
    key: "cachePageRef",
    value: function cachePageRef(pageNum, pageRef) {}
  }, {
    key: "isPageVisible",
    value: function isPageVisible(pageNumber) {
      return true;
    }
  }, {
    key: "isPageCached",
    value: function isPageCached(pageNumber) {
      return true;
    }
  }]);
  return SimpleLinkService;
}();
exports.SimpleLinkService = SimpleLinkService;

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AbortException", ({
  enumerable: true,
  get: function get() {
    return _pdf.AbortException;
  }
}));
Object.defineProperty(exports, "AnnotationEditorParamsType", ({
  enumerable: true,
  get: function get() {
    return _pdf.AnnotationEditorParamsType;
  }
}));
Object.defineProperty(exports, "AnnotationEditorType", ({
  enumerable: true,
  get: function get() {
    return _pdf.AnnotationEditorType;
  }
}));
Object.defineProperty(exports, "AnnotationFlag", ({
  enumerable: true,
  get: function get() {
    return _pdf.AnnotationFlag;
  }
}));
Object.defineProperty(exports, "AnnotationMode", ({
  enumerable: true,
  get: function get() {
    return _pdf.AnnotationMode;
  }
}));
Object.defineProperty(exports, "AnnotationType", ({
  enumerable: true,
  get: function get() {
    return _pdf.AnnotationType;
  }
}));
Object.defineProperty(exports, "CMapCompressionType", ({
  enumerable: true,
  get: function get() {
    return _pdf.CMapCompressionType;
  }
}));
Object.defineProperty(exports, "ColorSpace", ({
  enumerable: true,
  get: function get() {
    return _pdf.ColorSpace;
  }
}));
exports.DefaultExternalServices = exports.DownloadManager = void 0;
Object.defineProperty(exports, "DocumentInitParameters", ({
  enumerable: true,
  get: function get() {
    return _pdf.DocumentInitParameters;
  }
}));
Object.defineProperty(exports, "FeatureTest", ({
  enumerable: true,
  get: function get() {
    return _pdf.FeatureTest;
  }
}));
exports.GenericL10n = void 0;
Object.defineProperty(exports, "ImageKind", ({
  enumerable: true,
  get: function get() {
    return _pdf.ImageKind;
  }
}));
Object.defineProperty(exports, "InvalidPDFException", ({
  enumerable: true,
  get: function get() {
    return _pdf.InvalidPDFException;
  }
}));
exports.LoadScriptOption = void 0;
Object.defineProperty(exports, "LoopbackPort", ({
  enumerable: true,
  get: function get() {
    return _pdf.LoopbackPort;
  }
}));
Object.defineProperty(exports, "MissingPDFException", ({
  enumerable: true,
  get: function get() {
    return _pdf.MissingPDFException;
  }
}));
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function get() {
    return _pdf.OPS;
  }
}));
Object.defineProperty(exports, "PDFDataRangeTransport", ({
  enumerable: true,
  get: function get() {
    return _pdf.PDFDataRangeTransport;
  }
}));
Object.defineProperty(exports, "PDFDateString", ({
  enumerable: true,
  get: function get() {
    return _pdf.PDFDateString;
  }
}));
exports.PDFHistory = void 0;
Object.defineProperty(exports, "PDFWorker", ({
  enumerable: true,
  get: function get() {
    return _pdf.PDFWorker;
  }
}));
Object.defineProperty(exports, "PasswordResponses", ({
  enumerable: true,
  get: function get() {
    return _pdf.PasswordResponses;
  }
}));
Object.defineProperty(exports, "PermissionFlag", ({
  enumerable: true,
  get: function get() {
    return _pdf.PermissionFlag;
  }
}));
Object.defineProperty(exports, "PromiseCapability", ({
  enumerable: true,
  get: function get() {
    return _pdf.PromiseCapability;
  }
}));
Object.defineProperty(exports, "ReadableStream", ({
  enumerable: true,
  get: function get() {
    return _pdf.ReadableStream;
  }
}));
Object.defineProperty(exports, "RenderingCancelledException", ({
  enumerable: true,
  get: function get() {
    return _pdf.RenderingCancelledException;
  }
}));
Object.defineProperty(exports, "RenderingIntent", ({
  enumerable: true,
  get: function get() {
    return _pdf.RenderingIntent;
  }
}));
Object.defineProperty(exports, "SVGGraphics", ({
  enumerable: true,
  get: function get() {
    return _pdf.SVGGraphics;
  }
}));
Object.defineProperty(exports, "ScrollMode", ({
  enumerable: true,
  get: function get() {
    return _pdf.ScrollMode;
  }
}));
Object.defineProperty(exports, "SpreadMode", ({
  enumerable: true,
  get: function get() {
    return _pdf.SpreadMode;
  }
}));
Object.defineProperty(exports, "UnexpectedResponseException", ({
  enumerable: true,
  get: function get() {
    return _pdf.UnexpectedResponseException;
  }
}));
Object.defineProperty(exports, "UnknownErrorException", ({
  enumerable: true,
  get: function get() {
    return _pdf.UnknownErrorException;
  }
}));
Object.defineProperty(exports, "UnsupportedManager", ({
  enumerable: true,
  get: function get() {
    return _pdf.UnsupportedManager;
  }
}));
Object.defineProperty(exports, "Util", ({
  enumerable: true,
  get: function get() {
    return _pdf.Util;
  }
}));
Object.defineProperty(exports, "VerbosityLevel", ({
  enumerable: true,
  get: function get() {
    return _pdf.VerbosityLevel;
  }
}));
Object.defineProperty(exports, "XRefEntryException", ({
  enumerable: true,
  get: function get() {
    return _pdf.XRefEntryException;
  }
}));
Object.defineProperty(exports, "apiPageLayoutToViewerModes", ({
  enumerable: true,
  get: function get() {
    return _pdf.apiPageLayoutToViewerModes;
  }
}));
Object.defineProperty(exports, "apiPageModeToViewerModes", ({
  enumerable: true,
  get: function get() {
    return _pdf.apiPageModeToViewerModes;
  }
}));
Object.defineProperty(exports, "build", ({
  enumerable: true,
  get: function get() {
    return _pdf.build;
  }
}));
Object.defineProperty(exports, "createPromiseCapability", ({
  enumerable: true,
  get: function get() {
    return _pdf.createPromiseCapability;
  }
}));
Object.defineProperty(exports, "createValidAbsoluteUrl", ({
  enumerable: true,
  get: function get() {
    return _pdf.createValidAbsoluteUrl;
  }
}));
Object.defineProperty(exports, "getDocument", ({
  enumerable: true,
  get: function get() {
    return _pdf.getDocument;
  }
}));
Object.defineProperty(exports, "getFilenameFromUrl", ({
  enumerable: true,
  get: function get() {
    return _pdf.getFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getVerbosityLevel", ({
  enumerable: true,
  get: function get() {
    return _pdf.getVerbosityLevel;
  }
}));
Object.defineProperty(exports, "isPdfFile", ({
  enumerable: true,
  get: function get() {
    return _pdf.isPdfFile;
  }
}));
Object.defineProperty(exports, "isSameOrigin", ({
  enumerable: true,
  get: function get() {
    return _pdf.isSameOrigin;
  }
}));
Object.defineProperty(exports, "isValidFetchUrl", ({
  enumerable: true,
  get: function get() {
    return _pdf.isValidFetchUrl;
  }
}));
Object.defineProperty(exports, "loadScript", ({
  enumerable: true,
  get: function get() {
    return _pdf.loadScript;
  }
}));
exports.pdfjs = void 0;
Object.defineProperty(exports, "setVerbosityLevel", ({
  enumerable: true,
  get: function get() {
    return _pdf.setVerbosityLevel;
  }
}));
Object.defineProperty(exports, "shadow", ({
  enumerable: true,
  get: function get() {
    return _pdf.shadow;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function get() {
    return _pdf.version;
  }
}));
Object.defineProperty(exports, "warn", ({
  enumerable: true,
  get: function get() {
    return _pdf.warn;
  }
}));
var _pdf = _interopRequireWildcard(__webpack_require__(1));
var _viewer_compatibility = _interopRequireDefault(__webpack_require__(2));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var pdfjs = _pdf;
exports.pdfjs = pdfjs;
var GenericL10n = function GenericL10n(lang) {
  var _this = this;
  var l10n = new _pdf.SimpleL10n(function (key) {
    return _this._strings[key];
  });
  this._setL10n(l10n);
};
exports.GenericL10n = GenericL10n;
GenericL10n.prototype = {
  _setL10n: function _setL10n(l10n) {
    this.l10n = l10n;
    this._strings = this.l10n.getLanguage();
  },
  getLanguage: function getLanguage() {
    return this.l10n.getLanguage();
  },
  getDirection: function getDirection() {
    return this.l10n.getDirection();
  },
  get: function get(key, args, fallback) {
    return this.l10n.get(key, args, fallback);
  },
  translate: function translate(element) {
    this.l10n.translate(element);
  }
};
var LoadScriptOption = {
  PAGE_SCRIPT: "page",
  WORKER_SCRIPT: "worker"
};
exports.LoadScriptOption = LoadScriptOption;
function loadScript(src, option) {
  if (option === LoadScriptOption.WORKER_SCRIPT) {
    if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
      _pdf.PDFWorker.workerSrc = src;
      return Promise.resolve();
    }
    return (0, _pdf.loadScript)(src);
  }
}
if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
  (0, _pdf.setPDFNetworkStreamFactory)(function (params) {
    if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("fetch") && (0, _pdf.isValidFetchUrl)(params.url)) {
      return new _pdf.PDFNetworkStream(params);
    }
    return new _pdf.PDFNodeStream(params);
  });
}
var DefaultExternalServices = _pdf.DefaultExternalServices;
exports.DefaultExternalServices = DefaultExternalServices;
var DownloadManager = function DownloadManager() {
  this._openBlobUrls = new WeakMap();
};
exports.DownloadManager = DownloadManager;
DownloadManager.prototype = {
  downloadUrl: function DownloadManager_downloadUrl(url, filename) {
    if (!(0, _pdf.createValidAbsoluteUrl)(url, "http://example.com")) {
      return;
    }
    (0, _pdf.download)(url + "#pdfjs.action=download", filename);
  },
  downloadData: function DownloadManager_downloadData(data, filename, contentType) {
    var blobUrl = (0, _pdf.createObjectURL)(data, contentType, this._openBlobUrls.has(data));
    (0, _pdf.download)(blobUrl, filename);
  },
  download: function DownloadManager_download(blob, url, filename, sourceEventType) {
    var blobUrl = URL.createObjectURL(blob);
    var onetimeDonwload = true;
    if (sourceEventType === "save") {
      (0, _pdf.download)(blobUrl, filename);
      return;
    }
    if (this._openBlobUrls.has(blob)) {
      var oldBlobUrl = this._openBlobUrls.get(blob);
      this._openBlobUrls.delete(blob);
      URL.revokeObjectURL(oldBlobUrl);
      onetimeDonwload = false;
    }
    this._openBlobUrls.set(blob, blobUrl);
    var viewerUrl;
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
      viewerUrl = blobUrl;
    } else if (PDFJSDev.test("CHROME")) {
      viewerUrl = "chrome://pdf.js/content/web/viewer.html?file=" + encodeURIComponent(blobUrl);
    }
    try {
      window.open(viewerUrl);
    } catch (ex) {
      console.error("download: ".concat(ex.message));
      URL.revokeObjectURL(blobUrl);
      this._openBlobUrls.delete(blob);
    }
  },
  openOrDownloadData: function openOrDownloadData(element, data, filename) {
    var isPdfData = (0, _pdf.isPdfFile)(filename);
    var contentType = isPdfData ? "application/pdf" : "";
    if (isPdfData) {
      var blob = new Blob([data], {
        type: contentType
      });
      this.download(blob, "", filename, "fileopen");
    } else {
      this.downloadData(data, filename, contentType);
    }
  },
  downloadFile: function downloadFile(file, sourceEventType) {
    var blob = new Blob([file], {
      type: file.type
    });
    this.download(blob, "", file.name, sourceEventType);
  }
};
var PDFHistory = function PDFHistory(_ref) {
  var linkService = _ref.linkService,
    eventBus = _ref.eventBus;
  this.linkService = linkService;
  this.eventBus = eventBus;
  this.initialized = false;
  this.initialBookmark = null;
  this.initialRotation = null;
  this._boundEvents = Object.create(null);
  this._isViewerInPresentationMode = false;
  this.eventBus.on("presentationmodechanged", this._onPresentationModeChanged.bind(this));
  this.eventBus.on("pagesinit", this._onPagesInit.bind(this));
};
exports.PDFHistory = PDFHistory;
PDFHistory.prototype = {
  initialize: function initialize(_ref2) {
    var fingerprint = _ref2.fingerprint,
      _ref2$resetHistory = _ref2.resetHistory,
      resetHistory = _ref2$resetHistory === void 0 ? false : _ref2$resetHistory,
      _ref2$updateUrl = _ref2.updateUrl,
      updateUrl = _ref2$updateUrl === void 0 ? false : _ref2$updateUrl;
    this.initialized = true;
    this.reInitialized = false;
    this.allowHashChange = true;
    this.historyUnlocked = true;
    this.isViewerInPresentationMode = false;
    this.previousHash = window.location.hash.substring(1);
    this.currentBookmark = "";
    this.currentPage = 0;
    this.updateUrl = updateUrl === true;
    this.fingerprint = fingerprint;
    this.currentUid = this.uid = 0;
    this.current = Object.create(null);
    if (resetHistory) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
        window.sessionStorage.removeItem("pdfjs.history");
      }
    }
    this._boundEvents.popstate = this._onPopState.bind(this);
    window.addEventListener("popstate", this._boundEvents.popstate);
    this._boundEvents.pagechange = function (evt) {
      if (!this.isStateUnchanged(evt)) {
        this.push({
          page: evt.pageNumber,
          hash: this.currentBookmark,
          rotation: this.linkService.rotation
        });
      }
    }.bind(this);
    this.eventBus.on("pagechanging", this._boundEvents.pagechange);
    this._boundEvents.updateviewarea = function (evt) {
      if (!this.isStateUnchanged(evt)) {
        this.push({
          page: evt.location.pageNumber,
          hash: this.currentBookmark,
          rotation: this.linkService.rotation
        });
      }
    }.bind(this);
    this.eventBus.on("updateviewarea", this._boundEvents.updateviewarea);
  },
  _onPopState: function _onPopState(evt) {
    if (!this.historyUnlocked) {
      return;
    }
    if (evt.state === null) {
      this.currentUid++;
      var hash = this.currentBookmark || this.initialBookmark;
      this.push({
        hash: hash,
        page: this.currentPage,
        rotation: this.linkService.rotation
      });
      return;
    }
    this.allowHashChange = false;
    this.eventBus.dispatch("popstate", {
      source: this,
      state: evt.state
    });
    this.allowHashChange = true;
  },
  _onPagesInit: function _onPagesInit() {
    this.reInitialized = true;
    var initialHash = this.initialBookmark;
    if (initialHash) {
      this.linkService.setHash(initialHash);
      this.initialBookmark = null;
    } else if (this.initialRotation) {
      this.linkService.rotation = this.initialRotation;
      this.initialRotation = null;
    }
  },
  _onPresentationModeChanged: function _onPresentationModeChanged(evt) {
    this.isViewerInPresentationMode = evt.active || evt.switchInProgress;
  },
  isStateUnchanged: function isStateUnchanged(evt) {
    var page = evt.pageNumber;
    var rotation = this.linkService.rotation;
    if (this.isViewerInPresentationMode) {
      page = Math.floor(page);
    }
    if (page === this.currentPage && rotation === this.current.rotation) {
      return true;
    }
    return false;
  },
  push: function push(params) {
    if (!this.initialized) {
      return;
    }
    if (params.dest !== undefined) {
      this.currentBookmark = this.linkService.getDestinationHash(params.dest);
    } else if (params.hash !== undefined) {
      this.currentBookmark = params.hash;
    }
    if (params.page !== undefined) {
      this.currentPage = params.page | 0;
    }
    if (params.rotation !== undefined) {
      this.current.rotation = params.rotation;
    }
    if (this.isStateUnchanged(params)) {
      return;
    }
    var newHash = this.currentBookmark;
    var oldUrl = window.location.href.split("#")[0];
    var newUrl = oldUrl + "#" + newHash;
    if (this.updateUrl) {
      if (newUrl === window.location.href) {
        return;
      }
      this.previousHash = newHash;
      window.location.hash = newHash;
      this.currentUid++;
      return;
    }
    if (this.allowHashChange && newHash !== this.previousHash) {
      this.previousHash = newHash;
      this.currentUid++;
    }
  },
  pushCurrentPosition: function pushCurrentPosition() {
    if (!this.initialized) {
      return;
    }
    this.push({
      hash: this.currentBookmark,
      page: this.linkService.page,
      rotation: this.linkService.rotation
    });
  },
  back: function back() {
    if (!this.initialized) {
      return;
    }
    this.historyUnlocked = false;
    window.history.back();
    this.historyUnlocked = true;
  },
  forward: function forward() {
    if (!this.initialized) {
      return;
    }
    this.historyUnlocked = false;
    window.history.forward();
    this.historyUnlocked = true;
  }
};
})();

/******/ })()
;
//# sourceMappingURL=pdf.js.map